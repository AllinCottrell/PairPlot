function scalar PairPlot (const list L "List of variables to plot",
                          const series factor[null] "Discrete series for factorization",
                          const series size[null] "Make point size a function of size (not supported yet!)",
      string filename[null] "Path+filename",
      bundle *opts[null] "Set options through bundle")

    if nelem(L) == 1
        printf "\nError: List of variables to plot mus comprise at least 2 series.\n"
        return 1
    endif

    # Initial settings
    bundle self
    if exists(opts)
        self = opts + default_options()
    else
        self = default_options()
    endif

    scalar self.n_L = nelem(L)

    if exists(factor)
        series self.factor = factor
    endif
    if settings_related_to_factor(&self)	# puts 'factor' into self
        return 1
    endif

    if !exists(filename)
        string filename = "display"
    endif
    if filename != "display"
        string self.file_type = get_filetype_from_filename(filename)
    else
        string self.file_type = "png"
    endif

    # Write plot related settings
    string buffer = write_settings(&self)

    # Write plot cmd + data
    if self.type == "triangle"
        string buffer += write_plot_cmd_and_data_tri(L, &self)	# triangle
    elif self.type == "matrix" || self.type == "row" || self.type == "row_transponed"
        string buffer += write_plot_cmd_and_data_mat(L, &self)		# all combinations
    endif

    return send_to_gnuplot(buffer, filename)
end function


function string get_filetype_from_filename (const string filename)
    /* Process passed filename and grab file extension. */

    scalar length = strlen(filename)
    string grab_dot_and_type = strstr(substr(filename, length-4, length), ".")
    string file_type = substr(grab_dot_and_type, 2, strlen(grab_dot_and_type))

    return file_type
end function



function scalar settings_related_to_factor (bundle *self)

    if inbundle(self, "factor")
        scalar self.n_factor_values = rows(values(self.factor))
        scalar isok = is_ok_length_pointtype_vector(self.n_factor_values, &self)
        if !isok
            return 1
        endif
    else
        self.key = 0						# dont print key/ legend in this case
        scalar self.n_factor_values = 1		# needed for making loops working
    endif

    return 0
end function


function scalar is_ok_length_pointtype_vector (const int n_values_factor, bundle *self)
    scalar n_pts = rows(vec(self.pointtype))
    if n_pts == 1
        return 1
    else
        if n_pts < n_values_factor
            printf "\nError: Your 'factor' series has %d distinct values\n\
              but you have set a vector 'pointtype with only %d elements.\n\n", n_values_factor, n_pts
            return 0
        endif
    endif
    return 1
end function


function string construct_terminal_cmd (bundle *self)
    /* Construct the terminal for output. */

    string set_cmd = "set terminal "

    if self.file_type == "png"
        set_cmd += "pngcairo"
    elif self.file_type == "pdf"
        set_cmd += "pdfcairo"
    elif self.file_type == "eps"
        set_cmd += "postscript eps"
    elif self.file_type == "svg"
        set_cmd += "svg"
    endif

    set_cmd += sprintf(" font '%s,%d' ", self.font, self.fontsize)
    if self.file_type != "svg"
        set_cmd += "color"
    endif
    set_cmd += ";"

    # Set size ratio
    set_cmd += sprintf("set size %.1f, %.1f\n", self.aspect_scale, self.aspect_scale)

    return set_cmd
end function


function string write_settings (bundle *self)
    /* Write various settings to a string buffer. */

    string buffer = ""

    string buffer += sprintf("set encoding utf8\n")
    string buffer += construct_terminal_cmd(&self)

    string buffer += write_linetype(&self)

    if self.type == "triangle" || self.type == "row_transponed"
        scalar r = self.n_L - 1
    elif self.type == "matrix"
        scalar r = self.n_L
    elif self.type == "row"
        scalar r = 1
    endif
    if self.type != "row_transponed"
        scalar c = self.n_L - 1
    else
        scalar c = 1
    endif

    string buffer += sprintf("set multiplot layout %d,%d\n", r, c)

    if self.transparency_level > 0
        if self.use_circles
            printf "\nWarning: Transparency is only supported for points but not circles.\n"
        else
            string buffer += sprintf("set style fill transparent solid %.1f noborder\n", \
              self.transparency_level)
        endif
    endif

    string buffer += sprintf("set datafile missing 'NaN'\n")
    string buffer += sprintf("set style line 101 lc rgb '#808080' lt 1 lw 1\n")
    string self.border_cmd = sprintf("set border 3 front ls 101\n")		# drop right and upper border
    string buffer += self.border_cmd
    #    string buffer += sprintf("set tics nomirror out scale 0.75\n")		# has no effect
    string buffer += write_options(&self)

    return buffer
end function


function bundle default_options (void)
    /* Default parameter values */

    bundle self = null

    scalar self.aspect_scale = 1.5			# scaling factor for size
    scalar self.fontsize = 8
    string self.font = "League Spartan"
    scalar self.pointsize = 0.5
    matrix self.pointtype = 7
    scalar self.offset_level = 0.02
    scalar self.key = 1						# print distinct values of factor variable
    string self.key_position = "top left"	# position legend (standatd gnuplot settings)
    scalar self.use_circles = 0
    scalar self.transparency_level = 0.5
    string self.type = "triangle"
    scalar self.tics = 1				# print no x/y tics
    scalar self.grid = 0	# add grid (works only if self.tics=1) - not supported!

    return self
end function


function scalar send_to_gnuplot (const string buffer,
                                 const string filename)
    /* Write buffer to temp file and send to gnuplot */

    string mytemp
    outfile --tempfile=mytemp --quiet
        print buffer
    end outfile

    catch gnuplot --input=@mytemp --output=@filename

    return $error
end function


function string write_plot_cmd_and_data_mat (const list L,
                                             bundle *self)
    /* For case self.type=="matrix" case */

    string BUFFER = ""

    loop foreach y L -q			# Row dimension
        loop foreach x L -q		# Col dimension
            if varname(L.$y) != varname(L.$x)

                string buffer = ""

                list yx = null
                list yx = L.$x L.$y

                outfile --buffer=buffer
                    write_labels(varnames(yx)[2], varnames(yx)[1])
                    write_plot_cmd(&self)
                    write_plot_data(yx, &self)
                end outfile

                BUFFER += buffer
            endif
        endloop

        if self.type == "row" || self.type == "row_transponed"
            break
        endif

    endloop

    BUFFER += sprintf("unset multiplot")

    return BUFFER
end function


function string write_plot_cmd_and_data_tri (const list L,
                                             bundle *self)
    /* For self.type=="triangle" case */

    string BUFFER = ""

    # 1) Loop over all possible combinations
    # -> Each one starts with a new 'plot' cmd
    # 2) For each combination, consider the n_factor_values

    scalar y_counter = 0

    loop foreach y L -q			# Row dimension
        y_counter++

        scalar x_counter = 0

        loop foreach x L -q		# Col dimension

            if y_counter == 1
                break
            endif

            x_counter++

            if varname(L.$y) != varname(L.$x)

                string buffer = ""

                list yx = null
                list yx = L.$x L.$y

                if y_counter > x_counter
                    outfile --buffer=buffer
                        write_labels(varnames(yx)[2], varnames(yx)[1])
                        write_plot_cmd(&self)
                        write_plot_data(yx, &self)
                    end outfile

                else
                    buffer = write_empty_subplot_cmd(buffer, &self)
                endif

                BUFFER += buffer
            endif

        endloop						# end loop over x

    endloop							# end loop over y

    BUFFER += sprintf("unset multiplot")

    return BUFFER
end function


function string write_empty_subplot_cmd (string buffer, bundle *self)
    /* Helper function which leaves an empty subplot for triangular matrix plot */

    outfile --buffer=buffer
        if self.key
            printf "set key off\n"
        endif
        printf "set border 0\n"
        printf "unset xlabel\n"
        printf "unset ylabel\n"
        printf "unset xtics\n"
        printf "unset ytics\n"
        printf "plot '-' with points ps 0\n0 \ne\n"	# Trick for not plotting any point
        if self.key && inbundle(self, "factor")
            printf "set key on\n"
        endif
        if self.tics
            printf "set xtics\n"
            printf "set ytics\n"
        endif
        printf "%s\n", self.border_cmd
    end outfile

    return buffer
end function


function void write_labels (const string yname, const string xname)
    printf "set ylabel '%s'\n", yname
    printf "set xlabel '%s'\n", xname
end function


function void write_plot_data (const list yx, bundle *self)
    /* Write data for a single subplot. */

    if inbundle(self, "factor")
        matrix factor_values = values(self.factor)
    endif

    loop i=1..self.n_factor_values -q

        if self.n_factor_values > 1
            smpl self.factor == factor_values[i] --restrict --replace
        endif

        smpl --no-missing yx
        matrix m_yx = {yx}

        loop j=1..$nobs -q		# TODO: Use 'print' statement instead of the loop -- faster for 'big data'?
            printf "%.3f %.3f", m_yx[j,1], m_yx[j,2]
            if j < $nobs
                printf "\n"
            else
                printf "\ne\n"
            endif
        endloop

    endloop
end function


function void write_plot_cmd (bundle *self)

    if rows(vec(self.pointtype)) == 1
        matrix pt = self.pointtype * ones(self.n_factor_values, 1)
    else
        matrix pt = self.pointtype
    endif

    if self.use_circles
        string plot_type = "circles"
    else
        string plot_type = "points"
    endif

    if self.key && inbundle(self, "factor")
        series factor = self.factor

        strings str_values_factor = strvals(factor)
        scalar factor_has_str_values = 1
        if nelem(str_values_factor) == 0 # factor includes only numeric values
            matrix num_values_factor = values(factor)
            scalar factor_has_str_values = 0
        endif
    endif

    printf "plot \\\n"
    loop i=1..self.n_factor_values -q
        printf "'-' using 1:2 w %s pt %d", plot_type, pt[i]

        if exists(factor_has_str_values)
            if factor_has_str_values
                printf " title '%s'", str_values_factor[i]
            else
                printf " title 'F=%d'", num_values_factor[i]
            endif
        endif

        if i < self.n_factor_values
            printf ", \\\n"
        else
            printf "\n"
        endif
    endloop

end function


function string write_options (bundle *self)

    scalar off_set = self.offset_level

    string options_out = ""

    outfile --buffer=options_out
        printf "set offsets "
        loop i=1..self.n_L -q
            if i < self.n_L
                printf "%.2f, ", off_set
            else
                printf "%.2f\n", off_set
            endif
        endloop

        if self.key
            printf "set key %s\n", self.key_position
        else
            printf "set nokey\n"
        endif
        if self.tics
            printf "set xtics\n"
            printf "set ytics\n"
        else
            printf "set noxtics\n"
            printf "set noytics\n"
        endif

        if self.grid
            printf "set style line 12 lc rgb '#808080' lt 0 lw 1\n"
            printf "set grid ls 12\n"
        endif

        printf "set pointsize %.2f\n", self.pointsize

    end outfile

    return options_out
end function


function strings get_color_definitions (void)
    /* Put your own definitions here. */

    strings color_definitions = defarray("#C41E3A", \
    "#4682B4", \
    "#FFBF00", \
    "#ff0000", \
    "#0000ff", \
    "#00cc00", \
    "#bf25b2", \
    "#8faab3", \
    "#ffa500")

    return color_definitions
end function


function string write_linetype (bundle *self)
    strings color_definitions = get_color_definitions()

    string linetype_out = ""
    outfile --buffer=linetype_out
        loop i=1..self.n_L -q
            printf "set linetype %d lc rgb '%s'\n", $i, color_definitions[i]
        endloop
    end outfile

    return linetype_out
end function
