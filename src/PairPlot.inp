function scalar has_min_two_series (const list L)
    /*  */

    if nelem(L) < 2
        printf "\nError: List of variables must be comprise at least two series.\n"
        return FALSE
    endif

    return TRUE
end function


function void add_information_of_factor (const series factor, bundle *self)
    /*  Gather information of factor series. */

    series self.factor_series = factor

    matrix self.factor_values = values(factor)
    scalar self.n_factors = nelem(self.factor_values)

    bundle b = getinfo(factor)
    if b.has_string_table
        strings self.factor_str_values = strvals(factor)
    endif
end function


function scalar PairPlot (const list L "List of variables to plot",
                          const series factor[null] "Discrete series for factorization",
                          bundle opts[null] "Set options through bundle")
    /* Main public function.
    return: TRUE on error, otherwise FALSE. */

    bundle self
    if exists(opts)
        self = opts
    endif
    self = self + default_options()

    # Some checks
    if nelem(self.filename) == 0
        printf "\nError: Invalid file name.\n"
        return TRUE
    endif
    if !has_min_two_series(L)
        return TRUE
    endif
    self.n_variables = nelem(L)

    # Handle eventual missing values
    list  ALL = L
    ALL += exists(factor) ? factor : null
    smpl ALL --no-missing

    # Set some global(s)
    string self.plot_type = (self.use_circles == TRUE) ? "circles" : \
                                                         "points"

    if exists(factor)
        add_information_of_factor(factor, &self)
    else
        scalar self.n_factors = 1
        matrix self.factor_values = {1}
    endif
    code = isok_length_pointtype_vector(self)
    if !code
        return TRUE
    endif

    self.filename = exists(filename) ? filename : self.filename
    add_filetype(&self)

    string buffer = write_settings(&self)
    string buffer += compile_gnuplot_cmd_data_buffer(L, self)

    return send_to_gnuplot(buffer, self.filename)
end function


function string type_to_function_map (const string type)
    /* Map type to function name. */

    map =_(\
            triangle = "write_plot_cmd_and_data_tri",\
            matrix = "write_plot_cmd_and_data_mat",\
            row = "write_plot_cmd_and_data_mat",\
            column = "write_plot_cmd_and_data_mat"\
          )

    return map["@type"]
end function

function string compile_gnuplot_cmd_data_buffer (const list L,
                                                 const bundle self)
    /*  Compile gnuplot commands and data buffer for plotting. */

    string funcname = type_to_function_map(self.type)

    return feval(funcname, L, self)
end function


function void GUI_PairPlot (const list L "List of variables to plot",
                            const series factor[null] "Discrete series for factorization",
                            int type[1:4:1] "Plot type" {"triangle", "matrix", "row", "column"})
    /* Helper function for GUI access. */
    bundle opts = null

    if type == 1
        string opts.type = "triangle"
    elif type == 2
        string opts.type = "matrix"
    elif type == 3
        string opts.type = "row"
    elif type == 4
        string opts.type = "column"
    endif
    if exists(factor)
        scalar err = PairPlot(L, factor,  opts)
    else
        scalar err = PairPlot(L, null, opts)
    endif
end function


function void add_filetype (bundle *self)
    /* Determine type for plot file. */

    if self.filename == "display"
        self.filetype = "png"
    else
        scalar length = strlen(self.filename)
        string s = substr(self.filename, (length - 4), length)
        string tmp = strstr(s, ".")
        string self.filetype = strsub(tmp, ".", "")
    endif
end function


function scalar isok_length_pointtype_vector (const bundle self)
    /* Make sure length of 'pointtype' vector is at least as long the number of distinct factor values.
    return: TRUE of length of 'pointtype' vector is at least as long the number of distinct factor values; otherwise FALSE*/

    if inbundle(self, "n_factors") && nelem(self.pointtype) < self.n_factors
        printf "\nError: 'factor' series has %d distinct values but you\n\
        have set a vector 'pointtype' with only %d elements. Abort.\n\n",\
            self.n_factors, nelem(self.pointtype)
        return FALSE
    endif

    return TRUE
end function


function string filetype_to_terminal_map (const string filetype)
    /* Return gnuplot terminal name depending on filetype. */

    map =_(\
            png = "pngcairo",\
            pdf = "pdfcairo",\
            eps = "postscript eps",\
            svg ="svg"\
          )

    return map["@filetype"]
end function


function string construct_terminal_cmd (const bundle self)
    /* Construct the terminal for output. */

    set force_decpoint on

    string set_cmd = "set terminal "
    set_cmd += filetype_to_terminal_map(self.filetype)
    set_cmd += sprintf(" font '%s,%d' ", self.font, self.fontsize)

    if self.filetype != "svg"
        set_cmd += "color"
    endif
    set_cmd += ";"

    # Set size ratio
    set_cmd += sprintf("set size %.1f, %.1f\n", self.aspect_scale, self.aspect_scale)

    set force_decpoint off

    return set_cmd
end function


function scalar plottype_to_rows_map (const bundle self)
    /* Determine number of rows of multiplot depending on plot type. */

    map =_(\
            triangle = self.n_variables - 1,
            column = self.n_variables - 1,
            matrix = self.n_variables,
            row = 1\
          )

    return map[self.type]
end function


function scalar plottype_to_cols_map (const bundle self)
    /* Determine number of columns of multiplot depending on plot type. */

    if self.type != "column"
        return self.n_variables - 1
    else
        return 1
    endif
end function


function string write_settings (bundle *self)
    /* Write various settings to a string buffer. */

    string buffer

    buffer += sprintf("set encoding utf8\n")
    buffer += construct_terminal_cmd(self)
    buffer += write_linetype(self.n_variables, get_color_definitions())

    buffer += sprintf("set multiplot layout %d,%d\n",\
                plottype_to_rows_map(self), plottype_to_cols_map(self))


    if self.transparency_level
        if self.use_circles
            printf "\nWarning: Transparency is only supported for points but not circles.\n"
        else
            set force_decpoint on
            buffer += sprintf("set style fill transparent solid %.1f noborder\n", \
              self.transparency_level)
            set force_decpoint off
        endif

    endif

    buffer += sprintf("set datafile missing '%s'\n", self.gnuplot_missing_value)
    buffer += sprintf("set style line 101 lc rgb '#808080' lt 1 lw 1\n")
    # drop right and upper border
    self.border_cmd = sprintf("set border 3 front ls 101\n")
    buffer += self.border_cmd
    buffer += write_options(self)

    return buffer
end function


function bundle default_options (void)
    /* Default parameter values. */

    bundle self = null

    scalar self.aspect_scale = 1.5	# scaling factor for size
    scalar self.fontsize = 8
    string self.font = "" # TODO: "League Spartan"?
    scalar self.pointsize = 0.5
    matrix self.pointtype = mshape(7, 20, 1)
    scalar self.offset_level = 0.02
    scalar self.with_key = 1	# print distinct values of factor variable
    string self.key_position = "top left"	# position of legend
    scalar self.use_circles = TRUE
    scalar self.transparency_level = 0
    string self.type = "triangle"
    scalar self.tics = TRUE		 # print no x/y tics
    scalar self.grid = FALSE     # add grid (works only if self.tics=1) - not supported!

    string self.gnuplot_missing_value = "NaN"
    string self.filename = "display"

    return self
end function


function scalar send_to_gnuplot (const string buffer,
                                 const string filename)
    /* Write buffer to temp file and send to gnuplot */

    string mytemp
    outfile --tempfile=mytemp --quiet
        print buffer
    end outfile

    catch gnuplot --input="@mytemp" --output="@filename"

    return $error
end function


function string write_plot_cmd_and_data_mat (const list L,
                                             const bundle self)
    /* For case self.type=="matrix" case */

    string BUFFER = ""

    set force_decpoint on

    loop foreach y L -q         # Row dimension

        loop foreach x L -q     # Col dimension
            if varname(L.$y) != varname(L.$x)

                string buffer = ""
                list yx = null
                list yx = L.$x L.$y
                strings vnames = varnames(yx)

                outfile --buffer=buffer
                    write_labels(vnames[2], vnames[1])
                    write_plot_cmd(self)
                    write_plot_data(yx, self)
                end outfile

                BUFFER += buffer
            endif
        endloop

        if self.type == "row" || self.type == "column"
            break
        endif
    endloop

    set force_decpoint off

    BUFFER += sprintf("unset multiplot")

    return BUFFER
end function


function string write_plot_cmd_and_data_tri (const list L,
                                             const bundle self)
    /* For self.type=="triangle" case */

    string BUFFER = ""
    set force_decpoint on

    # 1) Loop over all possible combinations
    # -> Each one starts with a new 'plot' cmd
    # 2) For each combination, consider the n_factors

    scalar y_counter = 0

    loop foreach y L -q			# Row dimension
        y_counter++

        scalar x_counter = 0

        loop foreach x L -q		# Column dimension
            if y_counter == 1
                break
            endif

            x_counter++

            if varname(L.$y) != varname(L.$x)
                string buffer = ""
                list yx = null
                list yx = L.$x L.$y
                strings vnames = varnames(yx)

                if y_counter > x_counter
                    outfile --buffer=buffer
                        write_labels(vnames[2], vnames[1])
                        write_plot_cmd(self)
                        write_plot_data(yx, self)
                    end outfile
                else
                    buffer = write_empty_subplot_cmd(self)
                endif

                BUFFER += buffer
            endif
        endloop						# end loop over x
    endloop							# end loop over y
    set force_decpoint off

    BUFFER += sprintf("unset multiplot")

    return BUFFER
end function


function string write_empty_subplot_cmd (const bundle self)
    /* Helper function which leaves an empty subplot for triangular matrix plot */

    string buffer

    outfile --buffer=buffer
        if self.with_key
            printf "set key off\n"
        endif
        printf "set border 0\n"
        printf "unset xlabel\n"
        printf "unset ylabel\n"
        printf "unset xtics\n"
        printf "unset ytics\n"
        printf "plot '-' with points ps 0\n0 \ne\n"	# Trick for not plotting any point

        if self.with_key && inbundle(self, "factor")
            printf "set key on\n"
        endif

        if self.tics
            printf "set xtics\n"
            printf "set ytics\n"
        endif
        printf "%s\n", self.border_cmd
    end outfile

    return buffer
end function


function void write_labels (const string yname, const string xname)
    printf "set ylabel '%s'\n", yname
    printf "set xlabel '%s'\n", xname
end function


function void write_plot_data (const list yx, const bundle self)
    /* Write data for a single subplot. */

    strings S = array(0)

    loop i=1..self.n_factors -q
        smpl full
        if self.n_factors > 1
            smpl self.factor_series == self.factor_values[i] --restrict
        endif

        smpl --no-missing yx
        matrix m = {yx}
        cnameset(m, S)   # avoid variable names as column labels
        printf "%16.3f", m_yx
        printf "\ne\n"
    endloop
end function


function void write_plot_cmd (const bundle self)
    /* Compile gnuplot initial commands. */

    printf "plot \\\n"

    loop i=1..self.n_factors -q
        printf "'-' using 1:2 w %s pt %d", self.plot_type, self.pointtype[i]

        if inbundle(self, "factor_str_values")
            printf " title '%s'", self.factor_str_values[i]
        else
            if self.n_factors == 1
                print " title ''"
            else
                printf " title 'F=%d'", self.factor_values[i]
            endif
        endif

        if i < self.n_factors
            printf ", \\\n"
        else
            printf "\n"
        endif
    endloop
end function


function string set_offsets (const scalar offset_level)
    /* Write settings for offsets
    return: string, offsets parameters */

    string r = "set offsets "

    loop i=1..4 -q
        r += sprintf("%.2f", offset_level)
        r += i < 4 ? ", " : ""
    endloop

    return r
end function


function string write_options (const bundle self)
    /* Write gnuplot options to buffer and return as string. */

    set force_decpoint on

    string buffer

    outfile --buffer=buffer
        printf "%s\n", set_offsets(self.offset_level)

        if self.with_key
            printf "set key %s\n", self.key_position
        else
            printf "set nokey\n"
        endif
        if self.tics
            printf "set xtics\n"
            printf "set ytics\n"
        else
            printf "set noxtics\n"
            printf "set noytics\n"
        endif

        if self.grid
            printf "set style line 12 lc rgb '#808080' lt 0 lw 1\n"
            printf "set grid ls 12\n"
        endif

        printf "set pointsize %.2f\n", self.pointsize
    end outfile

    set force_decpoint off

    return buffer
end function


function strings get_color_definitions (void)
    /* Put your own definitions here. */

    /*
    return defarray(\
                    "#C41E3A", \
                    "#4682B4", \
                    "#FFBF00", \
                    "#ff0000", \
                    "#00cc00", \
                    "#8faab3", \
                    "#0000ff", \
                    "#bf25b2", \
                    "#ffa500"\
                    )
    */

    # "dark2" palette
    return defarray(\
                    "#1B9E77",\
                    "#D95F02",\
                    "#7570B3",\
                    "#E7298A",\
                    "#66A61E",\
                    "#E6AB02",\
                    "#A6761D",\
                    "#666666"\
                    )
end function


function string write_linetype (const int n_variables[1::],
                                const strings color_definitions)
    /* Print linetype commands. */

    string linetype_out = ""
    scalar counter = 1

    outfile --buffer=linetype_out
        loop i=1..n_variables -q
            printf "set linetype %d lc rgb '%s'\n", $i, color_definitions[counter]
            counter = (counter == nelem(color_definitions)) ? 1 : (counter + 1)
        endloop
    end outfile

    return linetype_out
end function
