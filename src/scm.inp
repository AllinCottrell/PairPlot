
function scalar ScatterPlotMatrix (const list L,
                                   const series factor[null],
                                   string filename[null],
                                   bundle *opts[null])
    /* Main function */

    # Initial settings
    bundle self = default_options()
    if exists(opts)
        self = opts + default_options()  
    endif

    # TODO: Add check that rows(pointtype)=1 or if > 1 equal the number of distinct values of factor!

    if !exists(filename)
        string filename = "display"
    endif
    scalar n_L = nelem(L)
    string buffer = ""

    # Constructor
    string buffer += sprintf("set encoding utf8\n")
    string buffer += sprintf("set terminal pngcairo \
      font '%s,%d' size %d,%d noenhanced;", self.font, self.fontsize,\
      self.size_scaling*512, self.size_scaling*384)
    string buffer += write_linetype(L)
    string buffer += sprintf("set multiplot layout %d,%d\n", n_L, n_L)
    string buffer += write_options(L, &self)

    # Write plot cmd + data
    string buffer += write_plot_cmd_and_data(L, &self, factor)

    return send_to_gnuplot(buffer, filename)
end function

function bundle default_options (void)
    /* Define default parameter values */
    
    bundle self = null

    scalar self.size_scaling = 1.2	# scaling factor for size
    scalar self.fontsize = 8
    string self.font = "League Spartan"
    scalar self.pointsize = 0.5
    matrix self.pointtype = 7
    scalar self.offset_level = 0.02
    scalar self.key = 1				# print distinct values of factor variable

    return self
end function


function scalar send_to_gnuplot (const string buffer,
                                 const string filename)
    /* Write buffer to temp file and send to gnuplot */

    string mytemp
    outfile --tempfile=mytemp --quiet
        print buffer
    end outfile

    catch gnuplot --input=@mytemp --output=@filename

    return $error
end function

function string write_plot_cmd_and_data (const list L,
                                         bundle *self,
                                         const series factor[null])
    /* */

    string BUFFER = ""

    scalar n_factor_values = 1
    n_factor_values = (exists(factor)) ? rows(values(factor)) : n_factor_values

    # 1) Loop over all possible nelem(y)*(nelem(y)-1)) combinations
    # -> Each one starts with a new plot cmd
    # 2) For each combination, consider the n_factor_values


    loop foreach y L -q
        loop foreach x L -q
            
            # TODO
            #            if varname(L.$y) == varname(L.$x)
            #            else
            list yx = null
            list yx = L.$y L.$x
            string buffer = ""
            #            endif

            # New subplot always starts with 'plot' cmd
            outfile --buffer=buffer

                write_labels (varnames(yx)[1], varnames(yx)[2])                
                write_plot_cmd(&self, n_factor_values, factor)

                if exists(factor)
                    write_plot_data(yx, factor, n_factor_values)
                else
                    write_plot_data(yx, , n_factor_values)
                endif
            end outfile
            BUFFER += buffer

        endloop

    endloop

    BUFFER += sprintf("unset multiplot")	# TODO: only if nelem(L)>1?

    return BUFFER
end function


function void write_labels (const string yname, const string xname)
    printf "set ylabel '%s'\n", yname
    printf "set xlabel '%s'\n", xname
end function


function void write_plot_data (const list yx,
                               const series factor[null],
                               const int n_factor_values)
    /* Write data for a single subplot. */

    if n_factor_values > 1
        factor_values = values(factor)
    endif

    loop i=1..n_factor_values -q

        if n_factor_values > 1
            smpl factor == factor_values[i] --restrict --replace
        endif

        smpl --no-missing yx
        matrix m_yx = {yx}

        loop j=1..$nobs -q		# TODO: Use 'print' instead of the loop?
            printf "%.3f %.3f", m_yx[j,1], m_yx[j,2]
            if j < $nobs
                printf "\n"
            else
                printf "\ne\n"
            endif
        endloop

    endloop

end function


function void write_plot_cmd (bundle *self,
                              const int n_factor_values,
                              const series factor[null])
    /* */

    if rows(vec(self.pointtype)) == 1
        matrix pt = self.pointtype * ones(n_factor_values,1)
    else
        matrix pt = self.pointtype
    endif
    

    if self.key && exists(factor)
        strings str_values_factor = strvals(factor)
        scalar factor_has_str_values = 1
        if nelem(str_values_factor) == 0 # factor includes only numeric values
            matrix num_values_factor = values(factor)
            factor_has_str_values = 0
        endif
    endif
        
    printf "plot \\\n"
    loop i=1..n_factor_values -q
        printf "'-' using 1:2 w points pt %d", pt[i]
        
        if exists(factor_has_str_values)
            if factor_has_str_values
                printf " title 'factor=%s'", str_values_factor[i]
            else
                printf " title 'factor=%d'", num_values_factor[i]
            endif
        endif
        
        if i < n_factor_values
            printf ", \\\n"
        else
            printf "\n"
        endif
    endloop

end function


function string write_options (const list L, bundle *self)
    /* */

    scalar n_L = nelem(L)
    scalar off_set = self.offset_level


    string options_out = ""
    outfile --buffer=options_out
        printf "set offsets "
        loop i=1..n_L -q
            if i < n_L
                printf "%.2f, ", off_set
            else
                printf "%.2f\n", off_set
            endif
        endloop

        if self.key
            printf "set key top left\n"			# TODO: make position optional, e.g. 'bottom below'
        else
            printf "set nokey\n"
        endif
        printf "set noxtics\n"
        printf "set noytics\n"

        printf "set pointsize %.2f\n", self.pointsize

    end outfile

    return options_out
end function


function strings get_color_definitions (void)
    /* */

    strings color_definitions = defarray("#C41E3A", \
    "#4682B4", \
    "#FFBF00", \
    "#ff0000", \
    "#0000ff", \
    "#00cc00", \
    "#bf25b2", \
    "#8faab3", \
    "#ffa500")

    return color_definitions
end function


function string write_linetype (const list L)
    /* */

    strings color_definitions = get_color_definitions()

    string linetype_out = ""
    outfile --buffer=linetype_out
        loop i=1..nelem(L) -q
            printf "set linetype %d lc rgb '%s'\n", $i, color_definitions[i]
        endloop
    end outfile

    return linetype_out
end function
